From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrIvanPlays <ivan@mrivanplays.com>
Date: Tue, 11 Aug 2020 10:28:04 +0300
Subject: [PATCH] Per entity (type) collision settings

Base patch was the only player collisions patch, the original author of was tr7zw <tr7zw@live.de>
but pretty much the whole implementation changed.

This patch implements per entity (type) collision settings with 100% compatibility with bukkit api and
vanilla.

The whole code is based around 1 class, the EntityFilter class. Whole filtering logic is there.

Co-authored-by: tr7zw <tr7zw@live.de>

diff --git a/src/main/java/de/minebench/origami/OrigamiConfig.java b/src/main/java/de/minebench/origami/OrigamiConfig.java
index e2bbbfeb7e2505479e6a457294aaa550b97319ca..a89209347418b3006745c50043d0abdf2b91babc 100644
--- a/src/main/java/de/minebench/origami/OrigamiConfig.java
+++ b/src/main/java/de/minebench/origami/OrigamiConfig.java
@@ -125,6 +125,37 @@ public final class OrigamiConfig {
         private void fastFeatureSearchDontLoad() {
 		    fastFeatureSearchDontLoad = getBoolean("fast-feature-search-dont-load", false);
         }
+
+        public boolean playerCollisions = true;
+        public boolean animalCollisions = true;
+        public boolean ambientCollisions = true;
+        public boolean monsterCollisions = true;
+        public boolean villagerCollisions = true;
+        public boolean pillagerCollisions = true;
+        public boolean ironGolemCollisions = true;
+        public boolean miscCollisions = true;
+        public boolean itemCollisions = true;
+        public boolean waterCreatureCollisions = true;
+        public boolean waterAmbientCollisions = true;
+        public boolean allCollisionsEnabled = false;
+        private void specificCollisionSettings() {
+            playerCollisions = getBoolean("collisions.players", playerCollisions);
+            animalCollisions = getBoolean("collisions.animals", animalCollisions);
+            ambientCollisions = getBoolean("collisions.ambient", ambientCollisions);
+            monsterCollisions = getBoolean("collisions.monsters", monsterCollisions);
+            villagerCollisions = getBoolean("collisions.villagers", villagerCollisions);
+            pillagerCollisions = getBoolean("collisions.pillagers", pillagerCollisions);
+            ironGolemCollisions = getBoolean("collisions.iron-golems", ironGolemCollisions);
+            miscCollisions = getBoolean("collisions.misc", miscCollisions);
+            itemCollisions = getBoolean("collisions.items", itemCollisions);
+            waterCreatureCollisions = getBoolean("collisions.water-creature", waterCreatureCollisions);
+            waterAmbientCollisions = getBoolean("collisions.water-ambient", waterAmbientCollisions);
+
+            allCollisionsEnabled =
+                    playerCollisions && animalCollisions && ambientCollisions && monsterCollisions && villagerCollisions
+                            && pillagerCollisions && ironGolemCollisions && miscCollisions && itemCollisions
+                            && waterCreatureCollisions && waterAmbientCollisions;
+        }
         // Yatopia end
     }
 
diff --git a/src/main/java/dev/tr7zw/yatopia/EntityFilter.java b/src/main/java/dev/tr7zw/yatopia/EntityFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..669ff5861d6b32483a2294405fac3b1ecb41207a
--- /dev/null
+++ b/src/main/java/dev/tr7zw/yatopia/EntityFilter.java
@@ -0,0 +1,161 @@
+package dev.tr7zw.yatopia;
+
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.Multimap;
+import de.minebench.origami.OrigamiConfig;
+import java.util.function.Predicate;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityTypes;
+import net.minecraft.server.EnumCreatureType;
+import net.minecraft.server.IEntitySelector;
+import net.minecraft.server.ScoreboardTeamBase;
+import net.minecraft.server.World;
+import net.minecraft.server.WorldDataServer;
+
+public class EntityFilter {
+
+    private static Multimap<String, Predicate<Entity>> collisionChecks = HashMultimap.create();
+
+    public static void initializeCollisionChecks(String worldName, OrigamiConfig.WorldConfig config) {
+        if (collisionChecks.containsKey(worldName)) {
+            collisionChecks.removeAll(worldName);
+        }
+        if (!config.playerCollisions) {
+            collisionChecks.put(worldName, (entity) -> entity.getEntityType() != EntityTypes.PLAYER);
+        }
+        if (!config.animalCollisions) {
+            collisionChecks.put(worldName, (entity) -> entity.getEntityType().getEnumCreatureType() != EnumCreatureType.CREATURE);
+        }
+        if (!config.ambientCollisions) {
+            collisionChecks.put(worldName, (entity) -> entity.getEntityType().getEnumCreatureType() != EnumCreatureType.AMBIENT);
+        }
+        if (!config.waterAmbientCollisions) {
+            collisionChecks.put(worldName, (entity) -> entity.getEntityType().getEnumCreatureType() != EnumCreatureType.WATER_AMBIENT);
+        }
+        if (!config.waterCreatureCollisions) {
+            collisionChecks.put(worldName, (entity) -> entity.getEntityType().getEnumCreatureType() != EnumCreatureType.WATER_CREATURE);
+        }
+        Predicate<Entity> misc = (entity) -> {
+            if (config.miscCollisions) {
+                if (entity.getEntityType().getEnumCreatureType() == EnumCreatureType.MISC) {
+                    if (!config.villagerCollisions) {
+                        if (!config.ironGolemCollisions) {
+                            if (!config.itemCollisions) {
+                                return entity.getEntityType() != EntityTypes.VILLAGER
+                                        && entity.getEntityType() != EntityTypes.IRON_GOLEM
+                                        && entity.getEntityType() != EntityTypes.ITEM;
+                            } else {
+                                return entity.getEntityType() != EntityTypes.VILLAGER
+                                        && entity.getEntityType() != EntityTypes.IRON_GOLEM;
+                            }
+                        } else {
+                            return entity.getEntityType() != EntityTypes.VILLAGER;
+                        }
+                    }
+                }
+                return true;
+            } else {
+                if (entity.getEntityType().getEnumCreatureType() == EnumCreatureType.MISC) {
+                    if (config.villagerCollisions) {
+                        if (config.ironGolemCollisions) {
+                            if (config.itemCollisions) {
+                                return entity.getEntityType() == EntityTypes.VILLAGER
+                                        || entity.getEntityType() == EntityTypes.IRON_GOLEM
+                                        || entity.getEntityType() == EntityTypes.ITEM;
+                            } else {
+                                return entity.getEntityType() == EntityTypes.VILLAGER
+                                        || entity.getEntityType() == EntityTypes.IRON_GOLEM;
+                            }
+                        } else {
+                            return entity.getEntityType() == EntityTypes.VILLAGER;
+                        }
+                    } else {
+                        return false;
+                    }
+                } else {
+                    return true;
+                }
+            }
+        };
+        collisionChecks.put(worldName, (entity) -> {
+            if (config.monsterCollisions) {
+                if (!config.pillagerCollisions) {
+                    return entity.getEntityType() != EntityTypes.PILLAGER && misc.test(entity);
+                } else {
+                    return misc.test(entity);
+                }
+            } else {
+                if (!config.pillagerCollisions) {
+                    return entity.getEntityType().getEnumCreatureType() != EnumCreatureType.MONSTER && misc.test(entity);
+                } else {
+                    return entity.getEntityType() == EntityTypes.PILLAGER
+                            || (entity.getEntityType().getEnumCreatureType() != EnumCreatureType.MONSTER
+                            && misc.test(entity));
+                }
+            }
+        });
+    }
+
+    public static Predicate<Entity> getFilter(Entity entity) {
+        OrigamiConfig.WorldConfig config = entity.world.origamiConfig;
+        if (config.allCollisionsEnabled) {
+            return IEntitySelector.a(entity);
+        }
+
+        ScoreboardTeamBase entityTeam = entity.getScoreboardTeam();
+        ScoreboardTeamBase.EnumTeamPush entityTeamPush =
+                entityTeam == null ?
+                        ScoreboardTeamBase.EnumTeamPush.ALWAYS :
+                        entityTeam.getCollisionRule();
+
+        if (entityTeamPush == ScoreboardTeamBase.EnumTeamPush.NEVER || entity.world.isClientSide
+                || entity.isSpectator()) {
+            return tested -> false;
+        }
+
+        Predicate<Entity> ret = (tested) -> {
+            if (!tested.canCollideWith(entity) || !entity.canCollideWith(tested)) {
+                return false;
+            }
+            ScoreboardTeamBase testedTeam = tested.getScoreboardTeam();
+            ScoreboardTeamBase.EnumTeamPush testedPush =
+                    testedTeam == null ?
+                            ScoreboardTeamBase.EnumTeamPush.ALWAYS :
+                            testedTeam.getCollisionRule();
+
+            if (testedPush == ScoreboardTeamBase.EnumTeamPush.NEVER) {
+                return false;
+            }
+            if (testedTeam != null && entityTeam != null) {
+                // see IEntitySelector#a(Entity)
+                // copied from there, although for me this logic doesn't seem quite right
+                boolean ally = entityTeam.isAlly(testedTeam);
+
+                if ((entityTeamPush == ScoreboardTeamBase.EnumTeamPush.PUSH_OWN_TEAM ||
+                        testedPush == ScoreboardTeamBase.EnumTeamPush.PUSH_OWN_TEAM) && ally) {
+                    return false;
+                }
+                return (entityTeamPush != ScoreboardTeamBase.EnumTeamPush.PUSH_OTHER_TEAMS
+                        && testedPush != ScoreboardTeamBase.EnumTeamPush.PUSH_OTHER_TEAMS) || ally;
+            } else {
+                return testedPush == ScoreboardTeamBase.EnumTeamPush.ALWAYS &&
+                        entityTeamPush == ScoreboardTeamBase.EnumTeamPush.ALWAYS;
+            }
+        };
+
+        String worldName = getWorldName(entity.world);
+        if (!collisionChecks.containsKey(worldName)) {
+            initializeCollisionChecks(worldName, config);
+        }
+
+        for (Predicate<Entity> predicate : collisionChecks.get(worldName)) {
+            ret = ret.and(predicate);
+        }
+
+        return ret;
+    }
+
+    private static String getWorldName(World world) {
+        return ((WorldDataServer) world.worldData).getName();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index c30fee13723cef0f03eb5a87851158cf347fae3c..a4123c2c7dc84803194459895f29d35643b71d04 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -2846,7 +2846,7 @@ public abstract class EntityLiving extends Entity {
         // Paper - end don't run getEntities if we're not going to use its result
         // Tuinity start - reduce memory allocation from collideNearby
         List<Entity> list = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList();
-        this.world.getEntities(this, this.getBoundingBox(), IEntitySelector.a(this), list);
+        this.world.getEntities(this, this.getBoundingBox(), dev.tr7zw.yatopia.EntityFilter.getFilter(this), list); // Yatopia
         try {
         // Tuinity end - reduce memory allocation from collideNearby
 
