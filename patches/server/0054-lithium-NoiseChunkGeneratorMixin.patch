From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: JellySquid <jellysquid+atwork@protonmail.com>
Date: Sat, 26 Sep 2020 14:25:07 -0500
Subject: [PATCH] lithium NoiseChunkGeneratorMixin

Original code by JellySquid, licensed under LGPLv3
you can find the original code on https://github.com/jellysquid3/lithium-fabric/ (Yarn mappings)

diff --git a/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java b/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java
index 119804e5c12aca3f4fbfeaf424f46152f43b3941..1970bb29362710e04ff06990939772899bf5cab4 100644
--- a/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java
+++ b/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java
@@ -65,6 +65,7 @@ public final class ChunkGeneratorAbstract extends ChunkGenerator {
     private final int x;
     private ThreadLocal<me.jellysquid.mods.lithium.common.world.noise.SimplexNoiseCache> tlCache; // Yatopia
 
+
     public ChunkGeneratorAbstract(WorldChunkManager worldchunkmanager, long i, Supplier<GeneratorSettingBase> supplier) {
         this(worldchunkmanager, worldchunkmanager, i, supplier);
     }
@@ -112,42 +113,95 @@ public final class ChunkGeneratorAbstract extends ChunkGenerator {
         return this.w == i && ((GeneratorSettingBase) this.h.get()).a(resourcekey);
     }
 
-    private double a(int i, int j, int k, double d0, double d1, double d2, double d3) {
-        double d4 = 0.0D;
-        double d5 = 0.0D;
-        double d6 = 0.0D;
-        boolean flag = true;
-        double d7 = 1.0D;
+    private static double sampleOctave(NoiseGeneratorPerlin sampler, double x, double y, double z, double scaledVerticalScale, double scaledY, double frequency) {
+        return sampler.sample(x, y, z, scaledVerticalScale, scaledY) / frequency;
+    }
 
-        for (int l = 0; l < 16; ++l) {
-            double d8 = NoiseGeneratorOctaves.a((double) i * d0 * d7);
-            double d9 = NoiseGeneratorOctaves.a((double) j * d1 * d7);
-            double d10 = NoiseGeneratorOctaves.a((double) k * d0 * d7);
-            double d11 = d1 * d7;
-            NoiseGeneratorPerlin noisegeneratorperlin = this.q.a(l);
+    private double sampleNoise(int x, int y, int z, double horizontalScale, double verticalScale, double horizontalStretch, double verticalStretch) { return a(x, y, z, horizontalScale, verticalScale, horizontalStretch, verticalStretch); } // Yatopia - OBFHELPER
+    private double a(int x, int y, int z, double horizontalScale, double verticalScale, double horizontalStretch, double verticalStretch) {
+        // To generate it's terrain, Minecraft uses two different perlin noises.
+        // It interpolates these two noises to create the final sample at a position.
+        // However, the interpolation noise is not all that good and spends most of it's time at > 1 or < 0, rendering
+        // one of the noises completely unnecessary in the process.
+        // By taking advantage of that, we can reduce the sampling needed per block through the interpolation noise.
+
+        // This controls both the frequency and amplitude of the noise.
+        double frequency = 1.0;
+        double interpolationValue = 0.0;
+
+        // Calculate interpolation data to decide what noise to sample.
+        for (int octave = 0; octave < 8; octave++) {
+            double scaledVerticalScale = verticalStretch * frequency;
+            double scaledY = y * scaledVerticalScale;
+
+            interpolationValue += sampleOctave(this.s.a(octave),
+                    NoiseGeneratorOctaves.a(x * horizontalStretch * frequency),
+                    NoiseGeneratorOctaves.a(scaledY),
+                    NoiseGeneratorOctaves.a(z * horizontalStretch * frequency), scaledVerticalScale, scaledY, frequency);
+
+            frequency /= 2.0;
+        }
 
-            if (noisegeneratorperlin != null) {
-                d4 += noisegeneratorperlin.a(d8, d9, d10, d11, (double) j * d11) / d7;
-            }
+        double clampedInterpolation = (interpolationValue / 10.0 + 1.0) / 2.0;
+
+        if (clampedInterpolation >= 1) {
+            // Sample only upper noise, as the lower noise will be interpolated out.
+            frequency = 1.0;
+            double noise = 0.0;
+            for (int octave = 0; octave < 16; octave++) {
+                double scaledVerticalScale = verticalScale * frequency;
+                double scaledY = y * scaledVerticalScale;
+
+                noise += sampleOctave(this.r.a(octave),
+                        NoiseGeneratorOctaves.a(x * horizontalScale * frequency),
+                        NoiseGeneratorOctaves.a(scaledY),
+                        NoiseGeneratorOctaves.a(z * horizontalScale * frequency), scaledVerticalScale, scaledY, frequency);
 
-            NoiseGeneratorPerlin noisegeneratorperlin1 = this.r.a(l);
+                frequency /= 2.0;
+            }
 
-            if (noisegeneratorperlin1 != null) {
-                d5 += noisegeneratorperlin1.a(d8, d9, d10, d11, (double) j * d11) / d7;
+            return noise / 512.0;
+        } else if (clampedInterpolation <= 0) {
+            // Sample only lower noise, as the upper noise will be interpolated out.
+            frequency = 1.0;
+            double noise = 0.0;
+            for (int octave = 0; octave < 16; octave++) {
+                double scaledVerticalScale = verticalScale * frequency;
+                double scaledY = y * scaledVerticalScale;
+                noise += sampleOctave(this.q.a(octave),
+                        NoiseGeneratorOctaves.a(x * horizontalScale * frequency),
+                        NoiseGeneratorOctaves.a(scaledY),
+                        NoiseGeneratorOctaves.a(z * horizontalScale * frequency), scaledVerticalScale, scaledY, frequency);
+
+                frequency /= 2.0;
             }
 
-            if (l < 8) {
-                NoiseGeneratorPerlin noisegeneratorperlin2 = this.s.a(l);
+            return noise / 512.0;
+        } else {
+            // [VanillaCopy] SurfaceChunkGenerator#sampleNoise
+            // Sample both and interpolate, as in vanilla.
+
+            frequency = 1.0;
+            double lowerNoise = 0.0;
+            double upperNoise = 0.0;
 
-                if (noisegeneratorperlin2 != null) {
-                    d6 += noisegeneratorperlin2.a(NoiseGeneratorOctaves.a((double) i * d2 * d7), NoiseGeneratorOctaves.a((double) j * d3 * d7), NoiseGeneratorOctaves.a((double) k * d2 * d7), d3 * d7, (double) j * d3 * d7) / d7;
-                }
+            for (int octave = 0; octave < 16; octave++) {
+                // Pre calculate these values to share them
+                double scaledVerticalScale = verticalScale * frequency;
+                double scaledY = y * scaledVerticalScale;
+                double xVal = NoiseGeneratorOctaves.a(x * horizontalScale * frequency);
+                double yVal = NoiseGeneratorOctaves.a(scaledY);
+                double zVal = NoiseGeneratorOctaves.a(z * horizontalScale * frequency);
+
+                upperNoise += sampleOctave(this.r.a(octave), xVal, yVal, zVal, scaledVerticalScale, scaledY, frequency);
+                lowerNoise += sampleOctave(this.q.a(octave), xVal, yVal, zVal, scaledVerticalScale, scaledY, frequency);
+
+                frequency /= 2.0;
             }
 
-            d7 /= 2.0D;
+            // Vanilla behavior, return interpolated noise
+            return MathHelper.b(clampedInterpolation, lowerNoise / 512.0, upperNoise / 512.0);
         }
-
-        return MathHelper.b(d4 / 512.0D, d5 / 512.0D, (d6 / 10.0D + 1.0D) / 2.0D);
     }
 
     private double[] b(int i, int j) {
