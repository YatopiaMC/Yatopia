From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
<<<<<<< HEAD:patches/server/0020-Optimize-Hopper-logic.patch
From: Bud Gidiere <sgidiere@gmail.com>
Date: Thu, 16 Jul 2020 23:09:45 -0500
=======
From: tr7zw <tr7zw@live.de>
Date: Fri, 26 Jun 2020 01:11:47 +0200
>>>>>>> 1.16.1:patches/server/0026-Optimize-Hopper-logic.patch
Subject: [PATCH] Optimize Hopper logic


diff --git a/src/main/java/net/minecraft/server/BlockDropper.java b/src/main/java/net/minecraft/server/BlockDropper.java
index 1ce89c28c2b54278dc8f1c17f2d0ccb743a27b34..1b360140b6161e9cae96752943d574200b5ced4e 100644
--- a/src/main/java/net/minecraft/server/BlockDropper.java
+++ b/src/main/java/net/minecraft/server/BlockDropper.java
@@ -36,7 +36,7 @@ public class BlockDropper extends BlockDispenser {
 
             if (!itemstack.isEmpty()) {
                 EnumDirection enumdirection = (EnumDirection) world.getType(blockposition).get(BlockDropper.FACING);
-                IInventory iinventory = TileEntityHopper.b(world, blockposition.shift(enumdirection));
+                IInventory iinventory = TileEntityHopper.b(world, blockposition.shift(enumdirection), false);
                 ItemStack itemstack1;
 
                 if (iinventory == null) {
diff --git a/src/main/java/net/minecraft/server/BlockHopper.java b/src/main/java/net/minecraft/server/BlockHopper.java
<<<<<<< HEAD:patches/server/0020-Optimize-Hopper-logic.patch
index a29294fbc7cd6fcfff0df9eadd11de3bd7f1405e..31ee358f82c2193fa7f2fc4e01798126be89f349 100644
--- a/src/main/java/net/minecraft/server/BlockHopper.java
+++ b/src/main/java/net/minecraft/server/BlockHopper.java
@@ -1,182 +1,230 @@
 package net.minecraft.server;
 
-public class BlockHopper extends BlockTileEntity {
+import java.util.OptionalInt;
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockActionContext;
+import net.minecraft.server.BlockBase;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.BlockProperties;
+import net.minecraft.server.BlockStateBoolean;
+import net.minecraft.server.BlockStateDirection;
+import net.minecraft.server.BlockStateList;
+import net.minecraft.server.BlockTileEntity;
+import net.minecraft.server.Container;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityLiving;
+import net.minecraft.server.EnumBlockMirror;
+import net.minecraft.server.EnumBlockRotation;
+import net.minecraft.server.EnumDirection;
+import net.minecraft.server.EnumHand;
+import net.minecraft.server.EnumInteractionResult;
+import net.minecraft.server.EnumRenderType;
+import net.minecraft.server.IBlockAccess;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.IBlockDataHolder;
+import net.minecraft.server.IBlockState;
+import net.minecraft.server.IChatBaseComponent;
+import net.minecraft.server.IHopper;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.ITileInventory;
+import net.minecraft.server.InventoryUtils;
+import net.minecraft.server.ItemStack;
+import net.minecraft.server.MinecraftKey;
+import net.minecraft.server.MovingObjectPositionBlock;
+import net.minecraft.server.OperatorBoolean;
+import net.minecraft.server.PathMode;
+import net.minecraft.server.StatisticList;
+import net.minecraft.server.TileEntity;
+import net.minecraft.server.TileEntityHopper;
+import net.minecraft.server.VoxelShape;
+import net.minecraft.server.VoxelShapeCollision;
+import net.minecraft.server.VoxelShapes;
+import net.minecraft.server.World;
 
-    public static final BlockStateDirection FACING = BlockProperties.N;
-    public static final BlockStateBoolean ENABLED = BlockProperties.f;
-    private static final VoxelShape c = Block.a(0.0D, 10.0D, 0.0D, 16.0D, 16.0D, 16.0D);
-    private static final VoxelShape d = Block.a(4.0D, 4.0D, 4.0D, 12.0D, 10.0D, 12.0D);
-    private static final VoxelShape e = VoxelShapes.a(BlockHopper.d, BlockHopper.c);
-    private static final VoxelShape f = VoxelShapes.a(BlockHopper.e, IHopper.a, OperatorBoolean.ONLY_FIRST);
-    private static final VoxelShape g = VoxelShapes.a(BlockHopper.f, Block.a(6.0D, 0.0D, 6.0D, 10.0D, 4.0D, 10.0D));
-    private static final VoxelShape h = VoxelShapes.a(BlockHopper.f, Block.a(12.0D, 4.0D, 6.0D, 16.0D, 8.0D, 10.0D));
-    private static final VoxelShape i = VoxelShapes.a(BlockHopper.f, Block.a(6.0D, 4.0D, 0.0D, 10.0D, 8.0D, 4.0D));
-    private static final VoxelShape j = VoxelShapes.a(BlockHopper.f, Block.a(6.0D, 4.0D, 12.0D, 10.0D, 8.0D, 16.0D));
-    private static final VoxelShape k = VoxelShapes.a(BlockHopper.f, Block.a(0.0D, 4.0D, 6.0D, 4.0D, 8.0D, 10.0D));
-    private static final VoxelShape o = IHopper.a;
-    private static final VoxelShape p = VoxelShapes.a(IHopper.a, Block.a(12.0D, 8.0D, 6.0D, 16.0D, 10.0D, 10.0D));
-    private static final VoxelShape q = VoxelShapes.a(IHopper.a, Block.a(6.0D, 8.0D, 0.0D, 10.0D, 10.0D, 4.0D));
-    private static final VoxelShape r = VoxelShapes.a(IHopper.a, Block.a(6.0D, 8.0D, 12.0D, 10.0D, 10.0D, 16.0D));
-    private static final VoxelShape s = VoxelShapes.a(IHopper.a, Block.a(0.0D, 8.0D, 6.0D, 4.0D, 10.0D, 10.0D));
-
-    public BlockHopper(BlockBase.Info blockbase_info) {
-        super(blockbase_info);
-        this.j((IBlockData) ((IBlockData) ((IBlockData) this.blockStateList.getBlockData()).set(BlockHopper.FACING, EnumDirection.DOWN)).set(BlockHopper.ENABLED, true));
-    }
-
-    @Override
-    public VoxelShape b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, VoxelShapeCollision voxelshapecollision) {
-        switch ((EnumDirection) iblockdata.get(BlockHopper.FACING)) {
-            case DOWN:
-                return BlockHopper.g;
-            case NORTH:
-                return BlockHopper.i;
-            case SOUTH:
-                return BlockHopper.j;
-            case WEST:
-                return BlockHopper.k;
-            case EAST:
-                return BlockHopper.h;
-            default:
-                return BlockHopper.f;
-        }
-    }
-
-    @Override
-    public VoxelShape a_(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
-        switch ((EnumDirection) iblockdata.get(BlockHopper.FACING)) {
-            case DOWN:
-                return BlockHopper.o;
-            case NORTH:
-                return BlockHopper.q;
-            case SOUTH:
-                return BlockHopper.r;
-            case WEST:
-                return BlockHopper.s;
-            case EAST:
-                return BlockHopper.p;
-            default:
-                return IHopper.a;
-        }
-    }
-
-    @Override
-    public IBlockData getPlacedState(BlockActionContext blockactioncontext) {
-        EnumDirection enumdirection = blockactioncontext.getClickedFace().opposite();
-
-        return (IBlockData) ((IBlockData) this.getBlockData().set(BlockHopper.FACING, enumdirection.n() == EnumDirection.EnumAxis.Y ? EnumDirection.DOWN : enumdirection)).set(BlockHopper.ENABLED, true);
-    }
-
-    @Override
-    public TileEntity createTile(IBlockAccess iblockaccess) {
-        return new TileEntityHopper();
-    }
-
-    @Override
-    public void postPlace(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving, ItemStack itemstack) {
-        if (itemstack.hasName()) {
-            TileEntity tileentity = world.getTileEntity(blockposition);
-
-            if (tileentity instanceof TileEntityHopper) {
-                ((TileEntityHopper) tileentity).setCustomName(itemstack.getName());
-            }
-        }
-
-    }
-
-    @Override
-    public void onPlace(IBlockData iblockdata, World world, BlockPosition blockposition, IBlockData iblockdata1, boolean flag) {
-        if (!iblockdata1.a(iblockdata.getBlock())) {
-            this.a(world, blockposition, iblockdata);
-        }
-    }
-
-    @Override
-    public EnumInteractionResult interact(IBlockData iblockdata, World world, BlockPosition blockposition, EntityHuman entityhuman, EnumHand enumhand, MovingObjectPositionBlock movingobjectpositionblock) {
-        if (world.isClientSide) {
-            return EnumInteractionResult.SUCCESS;
-        } else {
-            TileEntity tileentity = world.getTileEntity(blockposition);
-
-            if (tileentity instanceof TileEntityHopper) {
-                entityhuman.openContainer((TileEntityHopper) tileentity);
-                entityhuman.a(StatisticList.INSPECT_HOPPER);
-            }
-
-            return EnumInteractionResult.CONSUME;
-        }
-    }
-
-    @Override
-    public void doPhysics(IBlockData iblockdata, World world, BlockPosition blockposition, Block block, BlockPosition blockposition1, boolean flag) {
-        this.a(world, blockposition, iblockdata);
-    }
-
-    private void a(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        boolean flag = !world.isBlockIndirectlyPowered(blockposition);
-
-        if (flag != (Boolean) iblockdata.get(BlockHopper.ENABLED)) {
-            world.setTypeAndData(blockposition, (IBlockData) iblockdata.set(BlockHopper.ENABLED, flag), 4);
-        }
-
-    }
-
-    @Override
-    public void remove(IBlockData iblockdata, World world, BlockPosition blockposition, IBlockData iblockdata1, boolean flag) {
-        if (!iblockdata.a(iblockdata1.getBlock())) {
-            TileEntity tileentity = world.getTileEntity(blockposition);
-
-            if (tileentity instanceof TileEntityHopper) {
-                InventoryUtils.dropInventory(world, blockposition, (TileEntityHopper) tileentity);
-                world.updateAdjacentComparators(blockposition, this);
-            }
-
-            super.remove(iblockdata, world, blockposition, iblockdata1, flag);
-        }
-    }
-
-    @Override
-    public EnumRenderType b(IBlockData iblockdata) {
-        return EnumRenderType.MODEL;
-    }
-
-    @Override
-    public boolean isComplexRedstone(IBlockData iblockdata) {
-        return true;
-    }
-
-    @Override
-    public int a(IBlockData iblockdata, World world, BlockPosition blockposition) {
-        return Container.a(world.getTileEntity(blockposition));
-    }
-
-    @Override
-    public IBlockData a(IBlockData iblockdata, EnumBlockRotation enumblockrotation) {
-        return (IBlockData) iblockdata.set(BlockHopper.FACING, enumblockrotation.a((EnumDirection) iblockdata.get(BlockHopper.FACING)));
-    }
-
-    @Override
-    public IBlockData a(IBlockData iblockdata, EnumBlockMirror enumblockmirror) {
-        return iblockdata.a(enumblockmirror.a((EnumDirection) iblockdata.get(BlockHopper.FACING)));
-    }
-
-    @Override
-    protected void a(BlockStateList.a<Block, IBlockData> blockstatelist_a) {
-        blockstatelist_a.a(BlockHopper.FACING, BlockHopper.ENABLED);
-    }
-
-    @Override
-    public void a(IBlockData iblockdata, World world, BlockPosition blockposition, Entity entity) {
-        TileEntity tileentity = world.getTileEntity(blockposition);
-
-        if (tileentity instanceof TileEntityHopper) {
-            ((TileEntityHopper) tileentity).a(entity);
-        }
-
-    }
-
-    @Override
-    public boolean a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, PathMode pathmode) {
-        return false;
-    }
-}
+public class BlockHopper extends BlockTileEntity {
+	public static final BlockStateDirection FACING = BlockProperties.N;
+	public static final BlockStateBoolean ENABLED = BlockProperties.f;
+	private static final VoxelShape c = Block.a((double) 0.0, (double) 10.0, (double) 0.0, (double) 16.0, (double) 16.0,
+			(double) 16.0);
+	private static final VoxelShape d = Block.a((double) 4.0, (double) 4.0, (double) 4.0, (double) 12.0, (double) 10.0,
+			(double) 12.0);
+	private static final VoxelShape e = VoxelShapes.a((VoxelShape) d, (VoxelShape) c);
+	private static final VoxelShape f = VoxelShapes.a((VoxelShape) e, (VoxelShape) IHopper.a,
+			(OperatorBoolean) OperatorBoolean.ONLY_FIRST);
+	private static final VoxelShape g = VoxelShapes.a((VoxelShape) f,
+			(VoxelShape) Block.a((double) 6.0, (double) 0.0, (double) 6.0, (double) 10.0, (double) 4.0, (double) 10.0));
+	private static final VoxelShape h = VoxelShapes.a((VoxelShape) f, (VoxelShape) Block.a((double) 12.0, (double) 4.0,
+			(double) 6.0, (double) 16.0, (double) 8.0, (double) 10.0));
+	private static final VoxelShape i = VoxelShapes.a((VoxelShape) f,
+			(VoxelShape) Block.a((double) 6.0, (double) 4.0, (double) 0.0, (double) 10.0, (double) 8.0, (double) 4.0));
+	private static final VoxelShape j = VoxelShapes.a((VoxelShape) f, (VoxelShape) Block.a((double) 6.0, (double) 4.0,
+			(double) 12.0, (double) 10.0, (double) 8.0, (double) 16.0));
+	private static final VoxelShape k = VoxelShapes.a((VoxelShape) f,
+			(VoxelShape) Block.a((double) 0.0, (double) 4.0, (double) 6.0, (double) 4.0, (double) 8.0, (double) 10.0));
+	private static final VoxelShape o = IHopper.a;
+	private static final VoxelShape p = VoxelShapes.a((VoxelShape) IHopper.a, (VoxelShape) Block.a((double) 12.0,
+			(double) 8.0, (double) 6.0, (double) 16.0, (double) 10.0, (double) 10.0));
+	private static final VoxelShape q = VoxelShapes.a((VoxelShape) IHopper.a,
+			(VoxelShape) Block.a((double) 6.0, (double) 8.0, (double) 0.0, (double) 10.0, (double) 10.0, (double) 4.0));
+	private static final VoxelShape r = VoxelShapes.a((VoxelShape) IHopper.a, (VoxelShape) Block.a((double) 6.0,
+			(double) 8.0, (double) 12.0, (double) 10.0, (double) 10.0, (double) 16.0));
+	private static final VoxelShape s = VoxelShapes.a((VoxelShape) IHopper.a,
+			(VoxelShape) Block.a((double) 0.0, (double) 8.0, (double) 6.0, (double) 4.0, (double) 10.0, (double) 10.0));
+
+	public BlockHopper(BlockBase.Info var0) {
+		super(var0);
+		this.j((IBlockData) ((IBlockData) ((IBlockData) this.blockStateList.getBlockData()).set((IBlockState) FACING,
+				(Comparable) EnumDirection.DOWN)).set((IBlockState) ENABLED, (Comparable) Boolean.valueOf(true)));
+	}
+
+	public VoxelShape b(IBlockData var0, IBlockAccess var1, BlockPosition var2, VoxelShapeCollision var3) {
+		switch ((EnumDirection) var0.get((IBlockState) FACING)) {
+			case DOWN : {
+				return g;
+			}
+			case NORTH : {
+				return i;
+			}
+			case SOUTH : {
+				return j;
+			}
+			case WEST : {
+				return k;
+			}
+			case EAST : {
+				return h;
+			}
+		}
+		return f;
+	}
+
+	public VoxelShape a_(IBlockData var0, IBlockAccess var1, BlockPosition var2) {
+		switch ((EnumDirection) var0.get((IBlockState) FACING)) {
+			case DOWN : {
+				return o;
+			}
+			case NORTH : {
+				return q;
+			}
+			case SOUTH : {
+				return r;
+			}
+			case WEST : {
+				return s;
+			}
+			case EAST : {
+				return p;
+			}
+		}
+		return IHopper.a;
+	}
+
+	public IBlockData getPlacedState(BlockActionContext var0) {
+		EnumDirection var1;
+		return (IBlockData) ((IBlockData) this.getBlockData().set((IBlockState) FACING,
+				(Comparable) ((var1 = var0.getClickedFace().opposite()).n() == EnumDirection.EnumAxis.Y
+						? EnumDirection.DOWN
+						: var1))).set((IBlockState) ENABLED, (Comparable) Boolean.valueOf(true));
+	}
+
+	public TileEntity createTile(IBlockAccess var0) {
+		return new TileEntityHopper();
+	}
+
+	public void postPlace(World var0, BlockPosition var1, IBlockData var2, EntityLiving var3, ItemStack var4) {
+		TileEntity var5;
+		if (var4.hasName() && (var5 = var0.getTileEntity(var1)) instanceof TileEntityHopper) {
+			((TileEntityHopper) var5).setCustomName(var4.getName());
+		}
+	}
+
+	public void onPlace(IBlockData var0, World var1, BlockPosition var2, IBlockData var3, boolean var4) {
+		if (var3.a(var0.getBlock())) {
+			return;
+		}
+		this.a(var1, var2, var0);
+	}
+
+	public EnumInteractionResult interact(IBlockData var0, World var1, BlockPosition var2, EntityHuman var3,
+			EnumHand var4, MovingObjectPositionBlock var5) {
+		if (var1.isClientSide) {
+			return EnumInteractionResult.SUCCESS;
+		}
+		TileEntity var6 = var1.getTileEntity(var2);
+		if (var6 instanceof TileEntityHopper) {
+			var3.openContainer((ITileInventory) ((TileEntityHopper) var6));
+			var3.a(StatisticList.INSPECT_HOPPER);
+		}
+		return EnumInteractionResult.CONSUME;
+	}
+
+	public void doPhysics(IBlockData var0, World var1, BlockPosition var2, Block var3, BlockPosition var4,
+			boolean var5) {
+		this.a(var1, var2, var0);
=======
index a29294fbc7cd6fcfff0df9eadd11de3bd7f1405e..3a07fb76ebeddaf6b3676e04a995638cc43cf2f2 100644
--- a/src/main/java/net/minecraft/server/BlockHopper.java
+++ b/src/main/java/net/minecraft/server/BlockHopper.java
@@ -110,6 +110,12 @@ public class BlockHopper extends BlockTileEntity {
     @Override
     public void doPhysics(IBlockData iblockdata, World world, BlockPosition blockposition, Block block, BlockPosition blockposition1, boolean flag) {
         this.a(world, blockposition, iblockdata);
>>>>>>> 1.16.1:patches/server/0026-Optimize-Hopper-logic.patch
+		//YAPFA start
+		TileEntity tileEntity = world.getTileEntity(blockposition);
+		if (tileEntity instanceof TileEntityHopper) {
+			((TileEntityHopper)tileEntity).flushCaches();
+		}
+		// YAPFA end
     }
 
     private void a(World world, BlockPosition blockposition, IBlockData iblockdata) {
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index 20df9bd21d0e4d2579d05d79672da2eb26478044..a7f9d3e5ec1d582eb7101d5b6a969281b15be028 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -2,6 +2,7 @@ package net.minecraft.server;
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Optional;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
@@ -611,14 +612,44 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
 
     @Nullable
     private IInventory l() {
+    	if(this.cachedPush != null) {
+    		return this.cachedPush;
+    	}
         EnumDirection enumdirection = (EnumDirection) this.getBlock().get(BlockHopper.FACING);
 
-        return b(this.getWorld(), this.position.shift(enumdirection));
+        IInventory tmp = b(this.getWorld(), this.position.shift(enumdirection), this.cachedPushAir);
+        if(tmp != null && !(tmp instanceof IWorldInventory) && !(tmp instanceof Entity)) {
+        	this.cachedPush = tmp;
+        }else {
+        	if(tmp == null) {
+        		this.cachedPushAir = true;
+        	}
+        	return tmp;
+        }
+        if(this.cachedPush == null) {
+        	this.cachedPushAir = true;
+        }
+        return this.cachedPush;
     }
 
     @Nullable
     public static IInventory b(IHopper ihopper) {
-        return a(ihopper.getWorld(), ihopper.x(), ihopper.z() + 1.0D, ihopper.A());
+    	//YAPFA start
+    	if(ihopper instanceof TileEntityHopper) {
+    		TileEntityHopper hopper = (TileEntityHopper) ihopper;
+    		if(hopper.cachedAbove != null) {
+    			return hopper.cachedAbove;
+    		}
+    		IInventory inv = a(ihopper.getWorld(), ihopper.x(), ihopper.z() + 1.0D, ihopper.A(), hopper.cachedPullAir);
+    		hopper.cachedAbove = inv;
+    		if(hopper.cachedAbove == null) {
+    			hopper.cachedPullAir = true;
+    		}
+            return inv;
+    	} else {
+    		return a(ihopper.getWorld(), ihopper.x(), ihopper.z() + 1.0D, ihopper.A(), false);
+    	}
+        //YAPFA end
     }
 
     public static List<EntityItem> c(IHopper ihopper) {
@@ -633,14 +664,15 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
     }
 
     @Nullable
-    public static IInventory b(World world, BlockPosition blockposition) {
-        return a(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, true); // Paper
+    public static IInventory b(World world, BlockPosition blockposition, boolean skipBlockCheck) {
+        return a(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, true, skipBlockCheck); // YAPFA // Paper
     }
 
     @Nullable
-    public static IInventory a(World world, double d0, double d1, double d2) { return a(world, d0, d1, d2, false); } // Paper - overload to default false
-    public static IInventory a(World world, double d0, double d1, double d2, boolean optimizeEntities) { // Paper
-        Object object = null;
+    public static IInventory a(World world, double d0, double d1, double d2, boolean skipBlockCheck) { return a(world, d0, d1, d2, false, skipBlockCheck); } // YAPFA // Paper - overload to default false
+    public static IInventory a(World world, double d0, double d1, double d2, boolean optimizeEntities, boolean skipBlockCheck) { // YAPFA // Paper
+    	Object object = null;
+    	if(!skipBlockCheck) { // YAPFA
         BlockPosition blockposition = new BlockPosition(d0, d1, d2);
         if ( !world.isLoaded( blockposition ) ) return null; // Spigot
         IBlockData iblockdata = world.getType(blockposition);
@@ -658,15 +690,16 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
                 }
             }
         }
-
-        if (object == null && (!optimizeEntities || !org.bukkit.craftbukkit.util.CraftMagicNumbers.getMaterial(block).isOccluding())) { // Paper
+    	}
+        
+        if (object == null && (!optimizeEntities || true/*!org.bukkit.craftbukkit.util.CraftMagicNumbers.getMaterial(block).isOccluding()*/)) { // YAPFA // Paper
             List<Entity> list = world.getEntities((Entity) null, new AxisAlignedBB(d0 - 0.5D, d1 - 0.5D, d2 - 0.5D, d0 + 0.5D, d1 + 0.5D, d2 + 0.5D), IEntitySelector.d);
 
             if (!list.isEmpty()) {
                 object = (IInventory) list.get(world.random.nextInt(list.size()));
             }
         }
-
+        
         return (IInventory) object;
     }
 
@@ -728,4 +761,21 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
     protected Container createContainer(int i, PlayerInventory playerinventory) {
         return new ContainerHopper(i, playerinventory, this);
     }
+    
+    // YAPFA start
+    
+    private IInventory cachedAbove = null;
+    private IInventory cachedPush = null;
+    private boolean cachedPushAir = false;
+    private boolean cachedPullAir = false;
+    
+    public void flushCaches() {
+    	cachedAbove = null;
+    	cachedPush = null;
+    	cachedPushAir = false;
+    	cachedPullAir = false;
+    }
+    
+    // YAPFA end
+    
 }
