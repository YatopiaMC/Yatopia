From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Bud Gidiere <sgidiere@gmail.com>
Date: Sat, 26 Sep 2020 11:37:25 -0500
Subject: [PATCH] lithium PerlinNoiseSamplerMixin & NoiseChunkGeneratorMixin

Original code by JellySquid, licensed under LGPLv3
you can find the original code on https://github.com/jellysquid3/lithium-fabric/ (Yarn mappings)

diff --git a/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java b/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java
index 119804e5c12aca3f4fbfeaf424f46152f43b3941..c576ae6c9eea05577d6dfc7cadba04f5bb4efd6f 100644
--- a/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java
+++ b/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java
@@ -64,6 +64,10 @@ public final class ChunkGeneratorAbstract extends ChunkGenerator {
     protected final Supplier<GeneratorSettingBase> h;
     private final int x;
     private ThreadLocal<me.jellysquid.mods.lithium.common.world.noise.SimplexNoiseCache> tlCache; // Yatopia
+    private NoiseGeneratorOctaves lowerInterpolatedNoise; // Yatopia
+    private NoiseGeneratorOctaves upperInterpolatedNoise; // Yatopia
+    private NoiseGeneratorOctaves interpolationNoise; // Yatopia
+
 
     public ChunkGeneratorAbstract(WorldChunkManager worldchunkmanager, long i, Supplier<GeneratorSettingBase> supplier) {
         this(worldchunkmanager, worldchunkmanager, i, supplier);
@@ -112,43 +116,96 @@ public final class ChunkGeneratorAbstract extends ChunkGenerator {
         return this.w == i && ((GeneratorSettingBase) this.h.get()).a(resourcekey);
     }
 
-    private double a(int i, int j, int k, double d0, double d1, double d2, double d3) {
-        double d4 = 0.0D;
-        double d5 = 0.0D;
-        double d6 = 0.0D;
-        boolean flag = true;
-        double d7 = 1.0D;
-
-        for (int l = 0; l < 16; ++l) {
-            double d8 = NoiseGeneratorOctaves.a((double) i * d0 * d7);
-            double d9 = NoiseGeneratorOctaves.a((double) j * d1 * d7);
-            double d10 = NoiseGeneratorOctaves.a((double) k * d0 * d7);
-            double d11 = d1 * d7;
-            NoiseGeneratorPerlin noisegeneratorperlin = this.q.a(l);
+    private static double sampleOctave(NoiseGeneratorPerlin sampler, double x, double y, double z, double scaledVerticalScale, double scaledY, double frequency) {
+        return sampler.sample(x, y, z, scaledVerticalScale, scaledY) / frequency;
+    }
 
-            if (noisegeneratorperlin != null) {
-                d4 += noisegeneratorperlin.a(d8, d9, d10, d11, (double) j * d11) / d7;
+    private double sampleNoise(int x, int y, int z, double horizontalScale, double verticalScale, double horizontalStretch, double verticalStretch) { return a(x, y, z, horizontalScale, verticalScale, horizontalStretch, verticalStretch); } // Yatopia - OBFHELPER
+    private double a(int x, int y, int z, double horizontalScale, double verticalScale, double horizontalStretch, double verticalStretch) {
+            // To generate it's terrain, Minecraft uses two different perlin noises.
+            // It interpolates these two noises to create the final sample at a position.
+            // However, the interpolation noise is not all that good and spends most of it's time at > 1 or < 0, rendering
+            // one of the noises completely unnecessary in the process.
+            // By taking advantage of that, we can reduce the sampling needed per block through the interpolation noise.
+
+            // This controls both the frequency and amplitude of the noise.
+            double frequency = 1.0;
+            double interpolationValue = 0.0;
+
+            // Calculate interpolation data to decide what noise to sample.
+            for (int octave = 0; octave < 8; octave++) {
+                double scaledVerticalScale = verticalStretch * frequency;
+                double scaledY = y * scaledVerticalScale;
+
+                interpolationValue += sampleOctave(this.interpolationNoise.a(octave),
+                        NoiseGeneratorOctaves.a(x * horizontalStretch * frequency),
+                        NoiseGeneratorOctaves.a(scaledY),
+                        NoiseGeneratorOctaves.a(z * horizontalStretch * frequency), scaledVerticalScale, scaledY, frequency);
+
+                frequency /= 2.0;
             }
 
-            NoiseGeneratorPerlin noisegeneratorperlin1 = this.r.a(l);
+            double clampedInterpolation = (interpolationValue / 10.0 + 1.0) / 2.0;
 
-            if (noisegeneratorperlin1 != null) {
-                d5 += noisegeneratorperlin1.a(d8, d9, d10, d11, (double) j * d11) / d7;
-            }
+            if (clampedInterpolation >= 1) {
+                // Sample only upper noise, as the lower noise will be interpolated out.
+                frequency = 1.0;
+                double noise = 0.0;
+                for (int octave = 0; octave < 16; octave++) {
+                    double scaledVerticalScale = verticalScale * frequency;
+                    double scaledY = y * scaledVerticalScale;
 
-            if (l < 8) {
-                NoiseGeneratorPerlin noisegeneratorperlin2 = this.s.a(l);
+                    noise += sampleOctave(this.upperInterpolatedNoise.a(octave),
+                            NoiseGeneratorOctaves.a(x * horizontalScale * frequency),
+                            NoiseGeneratorOctaves.a(scaledY),
+                            NoiseGeneratorOctaves.a(z * horizontalScale * frequency), scaledVerticalScale, scaledY, frequency);
 
-                if (noisegeneratorperlin2 != null) {
-                    d6 += noisegeneratorperlin2.a(NoiseGeneratorOctaves.a((double) i * d2 * d7), NoiseGeneratorOctaves.a((double) j * d3 * d7), NoiseGeneratorOctaves.a((double) k * d2 * d7), d3 * d7, (double) j * d3 * d7) / d7;
+                    frequency /= 2.0;
                 }
-            }
 
-            d7 /= 2.0D;
-        }
+                return noise / 512.0;
+            } else if (clampedInterpolation <= 0) {
+                // Sample only lower noise, as the upper noise will be interpolated out.
+                frequency = 1.0;
+                double noise = 0.0;
+                for (int octave = 0; octave < 16; octave++) {
+                    double scaledVerticalScale = verticalScale * frequency;
+                    double scaledY = y * scaledVerticalScale;
+                    noise += sampleOctave(this.lowerInterpolatedNoise.a(octave),
+                            NoiseGeneratorOctaves.a(x * horizontalScale * frequency),
+                            NoiseGeneratorOctaves.a(scaledY),
+                            NoiseGeneratorOctaves.a(z * horizontalScale * frequency), scaledVerticalScale, scaledY, frequency);
+
+                    frequency /= 2.0;
+                }
 
-        return MathHelper.b(d4 / 512.0D, d5 / 512.0D, (d6 / 10.0D + 1.0D) / 2.0D);
-    }
+                return noise / 512.0;
+            } else {
+                // [VanillaCopy] SurfaceChunkGenerator#sampleNoise
+                // Sample both and interpolate, as in vanilla.
+
+                frequency = 1.0;
+                double lowerNoise = 0.0;
+                double upperNoise = 0.0;
+
+                for (int octave = 0; octave < 16; octave++) {
+                    // Pre calculate these values to share them
+                    double scaledVerticalScale = verticalScale * frequency;
+                    double scaledY = y * scaledVerticalScale;
+                    double xVal = NoiseGeneratorOctaves.a(x * horizontalScale * frequency);
+                    double yVal = NoiseGeneratorOctaves.a(scaledY);
+                    double zVal = NoiseGeneratorOctaves.a(z * horizontalScale * frequency);
+
+                    upperNoise += sampleOctave(this.upperInterpolatedNoise.a(octave), xVal, yVal, zVal, scaledVerticalScale, scaledY, frequency);
+                    lowerNoise += sampleOctave(this.lowerInterpolatedNoise.a(octave), xVal, yVal, zVal, scaledVerticalScale, scaledY, frequency);
+
+                    frequency /= 2.0;
+                }
+
+                // Vanilla behavior, return interpolated noise
+                return MathHelper.b(clampedInterpolation, lowerNoise / 512.0, upperNoise / 512.0);
+            }
+        }
 
     private double[] b(int i, int j) {
         double[] adouble = new double[this.o + 1];
diff --git a/src/main/java/net/minecraft/server/NoiseGeneratorPerlin.java b/src/main/java/net/minecraft/server/NoiseGeneratorPerlin.java
index d7ca619b228e2a5a461085e0c5222e6a36a66fe0..f6ec19f37d8b416ec01802c01932fc1bde3f9928 100644
--- a/src/main/java/net/minecraft/server/NoiseGeneratorPerlin.java
+++ b/src/main/java/net/minecraft/server/NoiseGeneratorPerlin.java
@@ -5,58 +5,53 @@ import java.util.Random;
 public final class NoiseGeneratorPerlin {
 
     private final byte[] d;
-    public final double a;
-    public final double b;
-    public final double c;
+    //Yatopia Faster Perlin
+    private static final int GRADIENT_STRIDE = 4;
+    private static final int GRADIENT_STRIDE_SH = 2;
+
+    private byte[] permutations;
+    public double originX;
+    public double originY;
+    public double originZ;
+
+    private final byte[] gradientTable = new byte[256 * GRADIENT_STRIDE];
+    //Yatopia End
 
     public NoiseGeneratorPerlin(Random random) {
-        this.a = random.nextDouble() * 256.0D;
-        this.b = random.nextDouble() * 256.0D;
-        this.c = random.nextDouble() * 256.0D;
         this.d = new byte[256];
+        for (int i = 0; i < 256; i++) {
+            int hash = this.permutations[i & 255] & 15;
 
-        int i;
-
-        for (i = 0; i < 256; ++i) {
-            this.d[i] = (byte) i;
+            for (int j = 0; j < 3; j++) {
+                this.gradientTable[(i * GRADIENT_STRIDE) + j] = (byte) NoiseGenerator3Handler.a[hash][j];
+            }
         }
+    }
 
-        for (i = 0; i < 256; ++i) {
-            int j = random.nextInt(256 - i);
-            byte b0 = this.d[i];
+    public final double sample(double x, double y, double z, double d, double e) { return a(x, y, z, d, e); } // Yatopia - OBFHELPER
+    public double a(double x, double y, double z, double d, double e) {
+        final double ox = x + this.originX;
+        final double oy = y + this.originY;
+        final double oz = z + this.originZ;
 
-            this.d[i] = this.d[i + j];
-            this.d[i + j] = b0;
-        }
+        final double fox = Math.floor(ox);
+        final double foy = Math.floor(oy);
+        final double foz = Math.floor(oz);
 
-    }
+        double oox = ox - fox;
+        double ooy = oy - foy;
+        double ooz = oz - foz;
 
-    public double a(double d0, double d1, double d2, double d3, double d4) {
-        double d5 = d0 + this.a;
-        double d6 = d1 + this.b;
-        double d7 = d2 + this.c;
-        int i = MathHelper.floor(d5);
-        int j = MathHelper.floor(d6);
-        int k = MathHelper.floor(d7);
-        double d8 = d5 - (double) i;
-        double d9 = d6 - (double) j;
-        double d10 = d7 - (double) k;
-        double d11 = MathHelper.j(d8);
-        double d12 = MathHelper.j(d9);
-        double d13 = MathHelper.j(d10);
-        double d14;
-
-        if (d3 != 0.0D) {
-            double d15 = Math.min(d4, d9);
-
-            d14 = (double) MathHelper.floor(d15 / d3) * d3;
-        } else {
-            d14 = 0.0D;
+        final double fx = MathHelper.j(oox);
+        final double fy = MathHelper.j(ooy);
+        final double fz = MathHelper.j(ooz);
+
+        if (d != 0.0D) {
+            ooy = ooy - (Math.floor(Math.min(e, ooy) / d) * d);
         }
 
-        return this.a(i, j, k, d8, d9 - d14, d10, d11, d12, d13);
+        return this.sample((int) fox, (int) foy, (int) foz, oox, ooy, ooz, fx, fy, fz);
     }
-
     private static double a(int i, double d0, double d1, double d2) {
         int j = i & 15;
 
@@ -67,22 +62,100 @@ public final class NoiseGeneratorPerlin {
         return this.d[i & 255] & 255;
     }
 
-    public double a(int i, int j, int k, double d0, double d1, double d2, double d3, double d4, double d5) {
-        int l = this.a(i) + j;
-        int i1 = this.a(l) + k;
-        int j1 = this.a(l + 1) + k;
-        int k1 = this.a(i + 1) + j;
-        int l1 = this.a(k1) + k;
-        int i2 = this.a(k1 + 1) + k;
-        double d6 = a(this.a(i1), d0, d1, d2);
-        double d7 = a(this.a(l1), d0 - 1.0D, d1, d2);
-        double d8 = a(this.a(j1), d0, d1 - 1.0D, d2);
-        double d9 = a(this.a(i2), d0 - 1.0D, d1 - 1.0D, d2);
-        double d10 = a(this.a(i1 + 1), d0, d1, d2 - 1.0D);
-        double d11 = a(this.a(l1 + 1), d0 - 1.0D, d1, d2 - 1.0D);
-        double d12 = a(this.a(j1 + 1), d0, d1 - 1.0D, d2 - 1.0D);
-        double d13 = a(this.a(i2 + 1), d0 - 1.0D, d1 - 1.0D, d2 - 1.0D);
-
-        return MathHelper.a(d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
+    public final double sample(int i, int j, int k, double d0, double d1, double d2, double d3, double d4, double d5) { return a(i, j, k, d0, d1, d2, d3, d4, d5); } // Yatopia - OBFHELPER
+    public double a(int sectionX, int sectionY, int sectionZ, double localX1, double localY1, double localZ1, double fadeLocalX, double fadeLocalY, double fadeLocalZ) {
+        final byte[] perm = this.permutations;
+
+        final int i = (perm[sectionX & 255] & 255) + sectionY;
+        final int l = (perm[(sectionX + 1) & 255] & 255) + sectionY;
+
+        final int j = (perm[255 & i] & 255) + sectionZ;
+        final int m = (perm[l & 255] & 255) + sectionZ;
+
+        final int k = (perm[(i + 1) & 255] & 255) + sectionZ;
+        final int n = (perm[(l + 1) & 255] & 255) + sectionZ;
+
+        final double localX2 = localX1 - 1.0D;
+        final double localY2 = localY1 - 1.0D;
+        final double localZ2 = localZ1 - 1.0D;
+
+        final int d00 = (j & 255) << GRADIENT_STRIDE_SH;
+        final int d01 = (m & 255) << GRADIENT_STRIDE_SH;
+        final int d02 = (k & 255) << GRADIENT_STRIDE_SH;
+        final int d03 = (n & 255) << GRADIENT_STRIDE_SH;
+
+        final int d10 = ((j + 1) & 255) << GRADIENT_STRIDE_SH;
+        final int d11 = ((m + 1) & 255) << GRADIENT_STRIDE_SH;
+        final int d12 = ((k + 1) & 255) << GRADIENT_STRIDE_SH;
+        final int d13 = ((n + 1) & 255) << GRADIENT_STRIDE_SH;
+
+        final byte[] grad = this.gradientTable;
+
+        final double g00x = grad[d00]     * localX1;
+        final double g00y = grad[d00 + 1] * localY1;
+        final double g00z = grad[d00 + 2] * localZ1;
+
+        final double g01x = grad[d01]     * localX2;
+        final double g01y = grad[d01 + 1] * localY1;
+        final double g01z = grad[d01 + 2] * localZ1;
+
+        final double g02x = grad[d02]     * localX1;
+        final double g02y = grad[d02 + 1] * localY2;
+        final double g02z = grad[d02 + 2] * localZ1;
+
+        final double g03x = grad[d03]     * localX2;
+        final double g03y = grad[d03 + 1] * localY2;
+        final double g03z = grad[d03 + 2] * localZ1;
+
+        final double g10x = grad[d10]     * localX1;
+        final double g10y = grad[d10 + 1] * localY1;
+        final double g10z = grad[d10 + 2] * localZ2;
+
+        final double g11x = grad[d11]     * localX2;
+        final double g11y = grad[d11 + 1] * localY1;
+        final double g11z = grad[d11 + 2] * localZ2;
+
+        final double g12x = grad[d12]     * localX1;
+        final double g12y = grad[d12 + 1] * localY2;
+        final double g12z = grad[d12 + 2] * localZ2;
+
+        final double g13x = grad[d13]     * localX2;
+        final double g13y = grad[d13 + 1] * localY2;
+        final double g13z = grad[d13 + 2] * localZ2;
+
+        final double g00 = g00x + g00y + g00z;
+        final double g01 = g01x + g01y + g01z;
+        final double g02 = g02x + g02y + g02z;
+        final double g03 = g03x + g03y + g03z;
+        final double g10 = g10x + g10y + g10z;
+        final double g11 = g11x + g11y + g11z;
+        final double g12 = g12x + g12y + g12z;
+        final double g13 = g13x + g13y + g13z;
+
+        final double ba1 = g01 - g00;
+        final double ba2 = g11 - g10;
+        final double dc1 = g03 - g02;
+        final double dc2 = g13 - g12;
+
+        final double dba1 = fadeLocalX * ba1;
+        final double dba2 = fadeLocalX * ba2;
+        final double ddc1 = fadeLocalX * dc1;
+        final double ddc2 = fadeLocalX * dc2;
+
+        final double dd0 = g00 + dba1;
+        final double dd1 = g10 + dba2;
+        final double dd2 = g02 + ddc1;
+        final double dd3 = g12 + ddc2;
+
+        final double aa0 = dd2 - dd0;
+        final double aa1 = dd3 - dd1;
+
+        final double y20 = fadeLocalY * aa0;
+        final double y31 = fadeLocalY * aa1;
+
+        final double aa2 = dd0 + y20;
+        final double aa3 = dd1 + y31;
+
+        return dd0 + y20 + (fadeLocalZ * (aa3 - aa2));
     }
 }
